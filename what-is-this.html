<!DOCTYPE html>
<html lang="en">
<!-- Mirrored from localhost:8080/what-is-this by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:59:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8" /><title>What is &quot;this&quot;? - How To Node - NodeJS</title><meta name="description" content="Learn the zen of coding in NodeJS." /><meta name="viewport" content="width=device-width" /><link href="style.css" rel="stylesheet" /><link href="print.css" rel="stylesheet" media="print" /><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="feed.xml" /><link href="favicon.ico" rel="icon" type="image/x-icon" /></head><body><div id="container"><div id="header"><a href="index.html"><img src="logo.png" alt="How to Node" class="logo" /><div class="tagline">The zen of coding in node.js</div></a></div><div id="main"><div class="article"><h1><a href="what-is-this.html">What is &quot;this&quot;?</a></h1><p class="old-node-warning">HEADS UP! This article was written for an older version of node.&nbsp;More up-to-date information may be available elsewhere.</p><p>Most people that learn JavaScript are coming from a background in another language.  This brings with it a view of how the world works that may be different from how it really works in JavaScript.  For this and other reasons, JavaScript is often misunderstood.  It's not entirely our fault, the language was designed to work like one thing (scheme-like), but look like another (c-like).  This article will describe lexical scope and the "<code>this</code>" variable and how to control them rather than be controlled by them when in coding JavaScript.</p>

<h2>It's all about where you are.</h2>

<p>In all programming languages, there is this idea of current scope and current context.  In JavaScript we have a lexical scope and a current "<code>this</code>" context.</p>

<p>In JavaScript all new scopes are created through "<code>function</code>" definitions.  But contrary to other c-like languages, this is the <em>only</em> way to make a new scope.  For loops don't do it, if blocks don't do it, plain curly braces assuredly don't do it.  This simplicity is both a blessing and a curse.  First let's have a couple of examples to explain creating scopes.</p>

<p>This is an example of global scope:</p>

<div class="snippet"><a href="what-is-this/global.js" class="code-link">global.js</a><pre><code><span class="com">// Define a couple of global variables</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Tim"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> age </span><span class="pun">=</span><span class="pln"> </span><span class="lit">28</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="com">// Access one of them from the global scope</span><span class="pln"><br />name</span><span class="pun">;</span></code></pre></div>

<p>This is an example of local scope:</p>

<div class="snippet"><a href="what-is-this/local.js" class="code-link">local.js</a><pre><code><span class="com">// Create a couple of local variables in a function.</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> newScope</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"tim"</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> age </span><span class="pun">=</span><span class="pln"> </span><span class="lit">28</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="com">// Try to access the local variables from the global scope</span><span class="pln"><br /></span><span class="com">// This will cause an error.</span><span class="pln"><br />name</span><span class="pun">;</span></code></pre></div>

<h3>Lexical Scope</h3>

<p>Lexical scope is the key to making closures work.  Here's a quote from wikipedia about closures and lexical scope:</p>

<blockquote>
  <p>In computer science, a closure is a first-class function with free variables that are bound in the lexical environment. Such a function is said to be "closed over" its free variables. A closure is defined within the scope of its free variables, and the extent of those variables is at least as long as the lifetime of the closure itself.</p>
</blockquote>

<p>So what does all that mean?  Here's an example:</p>

<div class="snippet"><a href="what-is-this/lexical.js" class="code-link">lexical.js</a><pre><code><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"outer"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> one</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"middle"</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> other </span><span class="pun">=</span><span class="pln"> </span><span class="str">"findme"</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">function</span><span class="pln"> two</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"inner"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">// Here `name` is "inner" and `other` is "findme"</span><span class="pln"><br />&nbsp; &nbsp; console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">({</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> other</span><span class="pun">:</span><span class="pln"> other</span><span class="pun">});</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; two</span><span class="pun">();</span><span class="pln"><br />&nbsp; </span><span class="com">// Here `name` is "middle" and `other` is "findme"</span><span class="pln"><br />&nbsp; console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">({</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> other</span><span class="pun">:</span><span class="pln"> other</span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br />one</span><span class="pun">();</span><span class="pln"><br /></span><span class="com">// Here `name` is "outer" and `other` is undefined.</span><span class="pln"><br />console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">({</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> name</span><span class="pun">});</span><span class="pln"><br />console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">({</span><span class="pln">other</span><span class="pun">:</span><span class="pln"> other</span><span class="pun">});</span></code></pre></div>

<p>Here we see that local variables in an inner scope can shadow variables by the same name in the outer scope.  But from the outside, variables in the inside don't exist.  Lexical scope is 100% based on the physical location of the variables in the nesting in the code.  It doesn't matter what path you might take to get to the inner function.  That's how closures are able to make inner variables usable.</p>

<div class="snippet"><a href="what-is-this/closure.js" class="code-link">closure.js</a><pre><code><span class="com">// Make a function that returns a closure function.</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> myModule</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"tim"</span><span class="pun">,</span><span class="pln"> age </span><span class="pun">=</span><span class="pln"> </span><span class="lit">28</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> greet</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="str">"Hello "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> name </span><span class="pun">+</span><span class="pln"> </span><span class="str">". &nbsp;Wow, you are "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> age </span><span class="pun">+</span><span class="pln"> </span><span class="str">" years old."</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="com">// call `myModule` to get a closure out of it.</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> greeter </span><span class="pun">=</span><span class="pln"> myModule</span><span class="pun">();</span><span class="pln"><br /></span><span class="com">// Call the closure</span><span class="pln"><br />greeter</span><span class="pun">();</span></code></pre></div>

<p>The variables <code>name</code> and <code>age</code> are local to the <code>myModule</code> function, but when we call <code>greeter</code> from the global scope, it doesn't throw an error.  This is because the <code>greet</code> function has <code>name</code> and <code>age</code> in its lexical scope and so they're accessible as if they were local variables.  Basically the way variable lookup works is that it goes up scope by scope looking for a variable by the requested name.</p>

<h3>The context of "<code>this</code>"</h3>

<p>In addition to the lexical scope.  JavaScript adds another layer of locality through the special keyword "<code>this</code>".  This keyword looks and acts like any other javascript variable except that you can't modify it.  It acts as a reference to the context object, and as an object, you can get to its properties through normal dot or bracket notation. The magic is that the value of "<code>this</code>" changes depending on what context your executing in.  In most cases, the context is the receiver of the message.  For example:</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#person</span></a><pre><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">Person</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; name</span><span class="pun">:</span><span class="pln"> </span><span class="str">"Tim"</span><span class="pun">,</span><span class="pln"><br />&nbsp; age</span><span class="pun">:</span><span class="pln"> </span><span class="lit">28</span><span class="pun">,</span><span class="pln"><br />&nbsp; greeting</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="str">"Hello "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">". &nbsp;Wow, you are "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">age </span><span class="pun">+</span><span class="pln"> </span><span class="str">" years old."</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">};</span><span class="pln"><br /><br /></span><span class="typ">Person</span><span class="pun">.</span><span class="pln">greeting</span><span class="pun">();</span></code></pre></div>

<p>Note that I was able to access <code>Person.name</code> and <code>Person.age</code> from within <code>Person.greeting</code>.  </p>

<h3>"<code>this</code>" is where it bites</h3>

<p>The previous code almost looks like objects from other languages.  But that's where it bites you.  As the author of the <code>Person</code> module, you have no assurance that "<code>this</code>" will be the same as "<code>Person</code>".  For example, what if I wanted to store the greeting function somewhere else:</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#standalone</span></a><pre><code><span class="kwd">var</span><span class="pln"> greeting </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">.</span><span class="pln">greeting</span><span class="pun">;</span><span class="pln"><br />greeting</span><span class="pun">();</span><span class="pln"> </span><span class="com">// Will get undefined for `this.name` and `this.age`</span></code></pre></div>

<p>The problem here is that "<code>this</code>" in the body of the greeting function is now the global object and not the <code>Person</code> object.  How about one more example just for fun:</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#dog</span></a><pre><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">Dog</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; name</span><span class="pun">:</span><span class="pln"> </span><span class="str">"Alfred"</span><span class="pun">,</span><span class="pln"><br />&nbsp; age</span><span class="pun">:</span><span class="pln"> </span><span class="lit">110</span><span class="pun">,</span><span class="pln"><br />&nbsp; greeting</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">.</span><span class="pln">greeting<br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="typ">Dog</span><span class="pun">.</span><span class="pln">greeting</span><span class="pun">();</span><span class="pln"> </span><span class="com">// This will work and it will show the dog's data.</span></code></pre></div>

<p>The greeting function in Dog and the function in Person are <strong>the same</strong> function.  They're both references to the same object in memory.  But depending on where it's called from, can change the value of "<code>this</code>".  Basically "<code>this</code>" is whatever object comes before the dot in the call.  That's why <code>Dog.greeting()</code> uses <code>Dog</code> as "<code>this</code>" and <code>Person.greeting()</code> uses <code>Person</code>.  When there is nothing before the function call, then the global object is used for "<code>this</code>".</p>

<h3>Taming "<code>this</code>"</h3>

<p>JavaScript comes with a couple of handy-dandy functions on <code>Function.prototype</code> called <code>call</code> and <code>apply</code>.  They work about the same, but take arguments differently.  Going on from the previous examples, let's make a new object that doesn't even have a <code>greeting</code> function, but can still be used by it.</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#alien</span></a><pre><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">Alien</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; name</span><span class="pun">:</span><span class="pln"> </span><span class="str">"Zygoff"</span><span class="pun">,</span><span class="pln"><br />&nbsp; age</span><span class="pun">:</span><span class="pln"> </span><span class="lit">5432</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="typ">Person</span><span class="pun">.</span><span class="pln">greeting</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="typ">Alien</span><span class="pun">);</span></code></pre></div>

<p>What we're saying here is to call the Person.greeting function, but inject the object <code>Alien</code> as the "<code>this</code>" value.  We could have used <code>apply</code> just the same for this example since there are no extra arguments.</p>

<p>Let's make a generic function that can work with any object that has <code>age</code> and <code>name</code> properties:</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#make-older</span></a><pre><code><span class="kwd">function</span><span class="pln"> makeOlder</span><span class="pun">(</span><span class="pln">years</span><span class="pun">,</span><span class="pln"> newname</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">age </span><span class="pun">+=</span><span class="pln"> years</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newname</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> newname</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>This function just adds years to any "<code>this</code>" object and optionally replaces the name.  It's not tied to any particular object. (In fact any function not using variables from outer scopes is independent) Here is how we would use it with either <code>call</code> or <code>apply</code>.</p>

<div class="snippet"><a href="what-is-this/this.js" class="code-link">this.js<span class="hash">#use-it</span></a><pre><code><span class="pln">makeOlder</span><span class="pun">.</span><span class="pln">call</span><span class="pun">(</span><span class="typ">Person</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Old Tim"</span><span class="pun">);</span><span class="pln"><br />makeOlder</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="typ">Dog</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Shaggy"</span><span class="pun">]);</span><span class="pln"><br />console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">({</span><span class="typ">Person</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Dog</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Dog</span><span class="pun">});</span></code></pre></div>

<p>The difference is that each extra argument to <code>call</code> is an argument passed to the function.  But with apply, there are only two arguments.  They are the "<code>this</code>" object and an array of the parameters to pass to the function.</p>

<h3>Binding "<code>this</code>"</h3>

<p>Sometimes we really like our nice OOP style code and want to force JS to act that way.  We don't like "<code>this</code>" changing on us depending on how we're calling it all the time.  The most common place where it bites me is in an event based system that takes callbacks as arguments.  Here is a simple example from jQuery.</p>

<div class="snippet"><a href="what-is-this/jquery.js" class="code-link">jquery.js<span class="hash">#cart</span></a><pre><code><span class="typ">Cart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; items</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="lit">1</span><span class="pun">,</span><span class="lit">4</span><span class="pun">,</span><span class="lit">2</span><span class="pun">],</span><span class="pln"><br />&nbsp; onClick</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">// Do something with this.items.</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br />$</span><span class="pun">(</span><span class="str">"#mybutton"</span><span class="pun">).</span><span class="pln">click</span><span class="pun">(</span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick</span><span class="pun">);</span></code></pre></div>

<p>While this looks ok, it's waiting for disaster.  Even though we have <code>Cart.onClick</code>, we're not calling the <code>onClick</code> function yet.  the jQuery code will accept is as some parameter and at that point it has no way of knowing that <code>onClick</code> came from the <code>Cart</code> object.  Your "<code>this</code>" won't be what you expect when it finally gets called.</p>

<p>Let's combine our knowledge of closures and lexical scope and make "<code>this</code>" scope act like it does in most OOP languages.</p>

<div class="snippet"><a href="what-is-this/jquery.js" class="code-link">jquery.js<span class="hash">#bad</span></a><pre><code><span class="pln">$</span><span class="pun">(</span><span class="str">"#mybutton"</span><span class="pun">).</span><span class="pln">click</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">});</span></code></pre></div>

<p>We created a little closure that then calls <code>Cart.onClick()</code>.  The problem with this (besides being long and ugly) is that is doesn't pass through any function parameters or return values.  We can fix that some.</p>

<div class="snippet"><a href="what-is-this/jquery.js" class="code-link">jquery.js<span class="hash">#better</span></a><pre><code><span class="pln">$</span><span class="pun">(</span><span class="str">"#mybutton"</span><span class="pun">).</span><span class="pln">click</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="typ">Cart</span><span class="pun">,</span><span class="pln"> arguments</span><span class="pun">)</span><span class="pln"> </span><span class="pun">});</span></code></pre></div>

<p>This works, but it's even harder to read and understand.  If you don't already know, "<code>arguments</code>" is another special keyword that is an array-like object that contains the arguments that were passed to the current inner-most function.</p>

<p>If Cart was a globally accessible singleton object we could just use the variable <code>Cart</code> directly instead of relying on "<code>this</code>", but that's often not the case when you have "classes" of objects sharing common functionality.</p>

<p>Wouldn't it be easier to somehow modify <code>Cart.onClick</code> so that "<code>this</code>" was always Cart from within it?</p>

<div class="snippet"><a href="what-is-this/jquery.js" class="code-link">jquery.js<span class="hash">#bind</span></a><pre><code><span class="kwd">function</span><span class="pln"> bind</span><span class="pun">(</span><span class="pln">fn</span><span class="pun">,</span><span class="pln"> scope</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> fn</span><span class="pun">.</span><span class="pln">apply</span><span class="pun">(</span><span class="pln">scope</span><span class="pun">,</span><span class="pln"> arguments</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick </span><span class="pun">=</span><span class="pln"> bind</span><span class="pun">(</span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Cart</span><span class="pun">);</span><span class="pln"><br />$</span><span class="pun">(</span><span class="str">"#mybutton"</span><span class="pun">).</span><span class="pln">click</span><span class="pun">(</span><span class="typ">Cart</span><span class="pun">.</span><span class="pln">onClick</span><span class="pun">);</span></code></pre></div>

<p>There are various ways of doing this and in fact it's often not the right solution.  If you're just trying to make JavaScript act like language X then this is a great little tool, but it's better to just learn the semantics of JavaScript.</p>

<p>Here we've just created a closure that has the scope embedded.  Then we replace Cart.onClick with the bound closure and use the apply magic to pass through any arguments and return value automatically.</p>

<h2>Var statements</h2>

<p>The var statement is really just a keyword to specify which nested scope a variable applies to.  In fact, if you never used <code>var</code>, then all your variables would be global and walk all over each other.</p>

<div class="snippet"><a href="what-is-this/var.js" class="code-link">var.js<span class="hash">#globals</span></a><pre><code><span class="pln">global_var </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> someFunc</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; another_global </span><span class="pun">=</span><span class="pln"> </span><span class="lit">42</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> local_var </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>This is especially dangerous in things like for loops:</p>

<div class="snippet"><a href="what-is-this/var.js" class="code-link">var.js<span class="hash">#loops</span></a><pre><code><span class="kwd">function</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">start</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">end</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> start</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="kwd">end</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; n </span><span class="pun">+=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="kwd">function</span><span class="pln"> nested_sum</span><span class="pun">(</span><span class="pln">num</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> num</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; n </span><span class="pun">+=</span><span class="pln"> sum</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br />nested_sum</span><span class="pun">(</span><span class="lit">3</span><span class="pun">);</span><span class="pln"> </span><span class="com">// Expected value is 10, but i values get tangled</span></code></pre></div>

<p>The <code>i</code> variable in both loops is the <strong>same</strong> variable and so the inner loop will break the outer loop and give the wrong answer.  Also if I had not put var statements before the two <code>n</code> variables, then they would walk over each other and give a wrong answer too.</p>

<p>There is one word of caution for <code>var</code> users.  It doesn't matter where in the function body you put the <code>var</code> word.  It only matters which function body you put it in.  And its scope is inner to function parameters. For example:</p>

<div class="snippet"><a href="what-is-this/var.js" class="code-link">var.js<span class="hash">#onevar</span></a><pre><code><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Tim"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> greet</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="com">// name is undefined</span><span class="pln"><br />&nbsp; </span><span class="com">// Lots of code, and them later on you have:</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> name</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br />greet</span><span class="pun">();</span><span class="pln"><br /><br /></span><span class="kwd">function</span><span class="pln"> greet2</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; console</span><span class="pun">.</span><span class="pln">dir</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="com">// name is "Tim" because functions arguments are special.</span><span class="pln"><br />&nbsp; </span><span class="com">// Lots of code, and them later on you have:</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> name</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br />greet2</span><span class="pun">(</span><span class="str">"Tim"</span><span class="pun">);</span></code></pre></div>

<p>This is why <a href="http://www.jslint.com/">jslint</a> tells you to put all your var statements at the top of a function.  I've actually had this one bite me because there was a page of code between the top of the function and the <code>var</code> statement.  I couldn't figure out why my variable I was passing in got set to <code>undefined</code> before the first line of the function body.</p>

<hr />

<h2>Conclusion</h2>

<p>There some universal rules that will go a long way to understanding scope in JavaScript:</p>

<ul>
<li>The only way to create a new scope is through the <code>function</code> keyword.  Nothing else, not even <code>for ... in</code> blocks create new scopes.</li>
<li>The <code>var</code> statement declares a variable as local to the current scope and the <strong>entire</strong> current scope, not just from the <code>var</code> statement onward.  These local variables shadow any existing variables from outer scopes.</li>
<li>All variables except "<code>this</code>" and "<code>arguments</code>" follow lexical scope.  Their meaning is defined by the <strong>physical location</strong> in the code.</li>
<li>The variables "<code>this</code>" and "<code>arguments</code>" change at <strong>every</strong> nesting level.  If you want to preserve them in a closure, then you need to first create a reference to their value through another variable that follows lexical scope.</li>
<li>The value of "<code>this</code>" is defined by <strong>how</strong> the function is called.  You can control this through use of <code>apply</code> and <code>call</code>.</li>
</ul>

<p>There are exceptions to these rules, but only when messing with things like function decompilation, <code>eval</code>, and the <code>with</code> keyword.  Even then you're still following the rules, just not in the way you'd expect. Function decompilation + <code>eval</code> transplants a function into a new lexical scope. And <code>with</code> can be used to make things like <code>this.name</code> appear as local lexical variables but work like "<code>this</code>" properties.</p><hr style="clear:both" /><div class="body" id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
var disqus_url = "http://howtonode.org/what-is-this";
//]]>
</script>
<script src="http://disqus.com/forums/howtonodeorg/embed.js" type="text/javascript"></script><a href="http://disqus.com/forums/howtonodeorg/?url=ref" class="view-thread">View the discussion thread.</a><a href="http://disqus.com/" class="dsq-brlink">blog comments powered by<span class="logo-disqus">Disqus</span></a>
<script type="text/javascript">
//<![CDATA[
(function() {
  var links = document.getElementsByTagName('a');
  var query = '?';
  for(var i = 0; i < links.length; i++) {
    if(links[i].href.indexOf('#disqus_thread') >= 0) {
      query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&amp;';
    }
  }
  document.write('<script charset="utf-8" type="text/javascript" src="//disqus.com/forums/howtonodeorg/get_num_replies.js' + query + '"></' + 'script>');
})();


//]]>
</script>
</div></div><div id="sidebar"><div class="aside author"><h4>About the Author</h4><img src="https://www.gravatar.com/avatar/c953ddd239707998340e1a6fbb3eeb46?r=pg&amp;s=200.jpg&amp;d=identicon" class="headshot" /><dl><dt>Name:</dt><dd>Tim Caswell</dd></dl><dl><dt>Github:</dt><dd><a href="https://github.com/creationix">creationix</a></dd></dl><dl><dt>Twitter:</dt><dd><a href="https://twitter.com/creationix">creationix</a></dd></dl><dl><dt>Location:</dt><dd>Red Lick, TX</dd></dl><dl><dt>Links:</dt><dd><a href="http://creationix.com/">Homepage</a></dd></dl></div><div class="aside"><h4>About this Article</h4><a href="http://twitter.com/share" data-count="horizontal" data-via="creationix" class="twitter-share-button">Tweet</a><script src="http://platform.twitter.com/widgets.js"></script><dl title="Mon Mar 08 2010 12:59:10 GMT-0600 (CST)"><dt>Date Released:</dt><dd>Monday, March  8, 2010</dd></dl><dl><dt>Node Version:</dt><dd><a href="http://github.com/joyent/node/tree/v0.1.102">node v0.1.102</a></dd></dl><dl><dt>Code Samples:</dt><dd><ul><li><a href="what-is-this/global.js">global.js</a></li><li><a href="what-is-this/local.js">local.js</a></li><li><a href="what-is-this/lexical.js">lexical.js</a></li><li><a href="what-is-this/closure.js">closure.js</a></li><li><a href="what-is-this/this.js">this.js</a></li><li><a href="what-is-this/jquery.js">jquery.js</a></li><li><a href="what-is-this/var.js">var.js</a></li></ul></dd></dl><dl><dt>Revisions:</dt><dd><ul></ul></dd></dl></div><div class="bubble"><h3>About HowToNode.org</h3>

<p>HowToNode.org is a community supported blog created by <a href="http://creationix.com/">Tim Caswell</a>. The purpose of the blog is to teach how to do various tasks in <a href="http://nodejs.org/">node.js</a> as well as teach fundamental concepts that are needed to write effective code.</p>

<p>This site is powered by <a href="http://github.com/creationix/wheat">Wheat</a>, a git based blogging engine written in <a href="http://nodejs.org/">node.JS</a>.</p>

<p>The content for this site is stored in a <a href="http://github.com/creationix/howtonode.org">git repository</a> that anyone can fork, write an article, and send a pull request. If your article passes the quality standards it will be published and help support the greater node community.</p></div></div><div id="footer"><p>&copy; 2011-2014 Tim Caswell under the MIT license.</p><p>Content and articles are copyrighted to the individual authors. Design by&nbsp;<a href="https://bengourley.co.uk/">Ben Gourley</a>. All code snippets used in the examples are in the public domain.</p><p>Wheat v2 running on node.js v16.4.2</p></div></div>
<script type="text/javascript">
//<![CDATA[
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
//]]>
</script>

<script type="text/javascript">
//<![CDATA[
try {
var pageTracker = _gat._getTracker("UA-12824411-1");
pageTracker._trackPageview();
} catch(err) {}
//]]>
</script>
</body>
<!-- Mirrored from localhost:8080/what-is-this by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:59:35 GMT -->
</html>