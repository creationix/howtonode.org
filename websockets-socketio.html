<!DOCTYPE html>
<html lang="en">
<!-- Mirrored from localhost:8080/websockets-socketio by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:58:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8" /><title>Websockets everywhere with Socket.IO - How To Node - NodeJS</title><meta name="description" content="Learn the zen of coding in NodeJS." /><meta name="viewport" content="width=device-width" /><link href="style.css" rel="stylesheet" /><link href="print.css" rel="stylesheet" media="print" /><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="feed.xml" /><link href="favicon.ico" rel="icon" type="image/x-icon" /></head><body><div id="container"><div id="header"><a href="index.html"><img src="logo.png" alt="How to Node" class="logo" /><div class="tagline">The zen of coding in node.js</div></a></div><div id="main"><div class="article"><h1><a href="websockets-socketio.html">Websockets everywhere with Socket.IO</a></h1><p>If you've stayed on top of the advances in the realtime web for the past few years, you've probably heard of different techniques aimed to reduce the latency (ie: speed) of the message exchange between a client and a server. If you're developing a multiplayer game, a chat application, or showing frequent updates of data like tweets or stock price changes, you probably want to <strong>reverse</strong> the traditional model of communication. So instead of requesting (polling) data on a specific interval of time, you want the server to send (push) data to the client.</p>

<p>Nowadays, terms like <code>long polling</code>, <code>comet</code> and <code>WebSocket</code> come to mind when it comes to developing a realtime web application or widget. But it's not always obvious how they work, their advantages, disadvantages and limitations, or even what percentage of the web browser market share supports them.</p>

<p><a href="http://socket.io/">Socket.IO</a> is a lightweight API that runs on the browser and looks like this:</p>

<div class="snippet"><a href="websockets-socketio/socketio-sample.js" class="code-link">socketio-sample.js</a><pre><code><span class="kwd">var</span><span class="pln"> socket </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> io</span><span class="pun">.</span><span class="typ">Socket</span><span class="pun">();</span><span class="pln"><br />socket</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'connect'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">// connected!</span><span class="pln"><br /></span><span class="pun">});</span><span class="pln"><br />socket</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'message'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">){</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">// message coming</span><span class="pln"><br /></span><span class="pun">});</span><span class="pln"><br />socket</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="str">'Hello world!'</span><span class="pun">);</span></code></pre></div>

<p>If you're familiar with <code>WebSocket</code>, the protocol that aims to simplify bi-directional communication over HTTP once and for all, you'll notice that it looks <strong>very</strong> similar. The difference is that Socket.IO, under the hood, will enable realtime communication for IE6-9, Firefox 3-4, Safari 3-5, Chrome 3-6, iOS (iPhone and iPad), and other commonplace user agents.</p>

<h2>Revisiting the history of the realtime web</h2>

<p>In this day and age, odds are that if you're a web developer you've used AJAX once or twice. Very much like what socket.io does for realtime, libraries like <code>jQuery</code> have provided abstractions that aim to remove the incompatibilities of what browsers offer for asynchronous HTTP requests (IE uses a proprietary ActiveX object, and mostly everyone else uses the standard XMLHttpRequest).</p>

<p>Now, if you wanted to make a realtime widget that retrieves data from the server, your first idea might look somewhat like this:</p>

<pre><code><span class="pln">setInterval</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; $</span><span class="pun">.</span><span class="pln">ajax</span><span class="pun">({</span><span class="pln"> url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/my/page'</span><span class="pun">,</span><span class="pln"> success</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">data</span><span class="pun">){</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// do something with the data</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">},</span><span class="pln"> </span><span class="lit">5000</span><span class="pun">);</span><span class="pln"><br /></span></code></pre>

<p>So, every 5 seconds we <code>poll</code> the server for new updates. In my book, that's almost as efficient as the <a href="http://www.rfc-editor.org/rfc/rfc1149.txt">transmission of IP Datagrams on pigeons</a>.</p>

<p>You might also want to try to reduce the interval, and say, put it at 100 milliseconds.</p>

<pre><code><span class="pln">setInterval</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">// now this should be fast!</span><span class="pln"><br />&nbsp; &nbsp; $</span><span class="pun">.</span><span class="pln">ajax</span><span class="pun">({</span><span class="pln"> url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/my/page'</span><span class="pun">,</span><span class="pln"> success</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">data</span><span class="pun">){}</span><span class="pln"> </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">},</span><span class="pln"> </span><span class="lit">100</span><span class="pun">);</span><span class="pln"><br /></span></code></pre>

<p>However, we're ignoring two major downsides now:</p>

<ul>
<li>The HTTP latency. Chances are that a complete roundtrip of the packets on a high speed internet connection will be around 200ms. But this is not always the case! If it were 500 or higher, then things might slow down. And they might slow down unnecessarily, because:</li>
<li>The server might not have any new data for us. In this case, we'd be producing a lot of network traffic, and request/response cycles overhead, for no purpose.</li>
</ul>

<h2>Introducing long polling</h2>

<p>Long polling addresses the weakness of traditional polling methods by asking the server for new information on a certain interval, but keeping the connection open if the server has nothing new for us. This technique dramatically decreases latency and network traffic, which means it efficiently disguises itself as a server-push technique.</p>

<pre><code><span class="kwd">function</span><span class="pln"> load</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; $</span><span class="pun">.</span><span class="pln">ajax</span><span class="pun">({</span><span class="pln"> url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/my/page'</span><span class="pun">,</span><span class="pln"> success</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// do something with the data</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">},</span><span class="pln"> complete</span><span class="pun">:</span><span class="pln"> load</span><span class="pun">,</span><span class="pln"> timeout</span><span class="pun">:</span><span class="pln"> </span><span class="lit">20000</span><span class="pln"> </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span></code></pre>

<h2>How about keeping the connection open?</h2>

<p>If you come from a more traditional programming environment (eg: Desktop software), you're probably wondering why we don't keep the connection open.</p>

<p>This is possible with at least two fairly well known techniques:</p>

<ul>
<li>XMLHttpRequest and the <code>multipart/x-mixed-replace</code> MIME type (which is enabled by setting <code>multipart = true</code> in the XMLHTTPRequest instance)</li>
</ul>

<p>Although it was introduced by Netscape in 1995 (yes, when some of us were still unable to read properly), the only commonplace user agent to support it is Firefox.</p>

<ul>
<li>An <code>&lt;iframe&gt;</code> populated with a response with the headers <code>Transfer-encoding: chunked</code> and <code>Connection: keep-alive</code>.</li>
</ul>

<p>The technique consists of writing <code>&lt;script&gt;</code> tags that call a function on the parent page as information becomes available to push to the client.</p>

<p>The disadvantage of this method is that it'll trigger a never-ending spinner or progress bar in most user agents, severely hurting the user experience. In Internet Explorer, this can be worked around by inserting the <code>&lt;iframe&gt;</code> in a hidden document (via the obscure ActiveX object <code>htmlfile</code>). This technique was exposed to me for the first time thanks to the Gmail Chat team. This gem was <a href="http://infrequently.org/2006/02/what-else-is-burried-down-in-the-depths-of-googles-amazing-javascript/">analyzed/discovered</a> back in the day by Alex Russell</p>

<p>By now, it's obvious that some lower-latency techniques are available to certain user agents, under certain conditions. The fundamental problem is that now the server has to treat HTTP requests differently, altering</p>

<ul>
<li>The headers sent with the response (Content-Type, Connection, etc).</li>
<li>The duration (a timeout is required for long-polling, but not all the others)</li>
<li>The "framing" of the messages. For multipart, each message has to be accompanied by a delimiter (boundary).</li>
<li>Random quirks (IE requires a certain number of dummy bytes at the beginning of the document streamed through the iframe).</li>
</ul>

<p>All these techniques try to minimize the latency of the <strong>incoming</strong> data from the server, but normal XMLHTTPRequest have to be used to <strong>send</strong> data from the client. Which brings us to the most optimal solution available today.</p>

<h2>One transport to rule them all</h2>

<p>Meet WebSocket, an effort "to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections", as the author Ian Hickson <a href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76">puts it</a>.</p>

<p>WebSocket takes advantage of the Upgrade header of the HTTP/1.1 specification, which means it's essentially a new protocol for communication:</p>

<pre><code><span class="typ">The</span><span class="pln"> </span><span class="typ">Upgrade</span><span class="pln"> general</span><span class="pun">-</span><span class="pln">header allows the client to specify what additional communication protocols it supports </span><span class="kwd">and</span><span class="pln"> would like to </span><span class="kwd">use</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> the server finds it appropriate to </span><span class="kwd">switch</span><span class="pln"> protocols</span><span class="pun">.</span><span class="pln"><br /></span><span class="typ">Examples</span><span class="pun">:</span><span class="pln"> HTTP</span><span class="pun">/</span><span class="lit">2.0</span><span class="pun">,</span><span class="pln"> SHTTP</span><span class="pun">/</span><span class="lit">1.3</span><span class="pun">,</span><span class="pln"> IRC</span><span class="pun">/</span><span class="lit">6.9</span><span class="pun">,</span><span class="pln"> RTA</span><span class="pun">/</span><span class="pln">x11<br />http</span><span class="pun">:</span><span class="com">//www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</span><span class="pln"><br /></span></code></pre>

<p>WebSocket won't close the connection after sending a message or receiving one. It's essentially "TCP for the web", but with a security model built in the protocol, a fairly rare framing system and UTF-8 encoding (no binary).</p>

<p>If we choose to implement it, some of the problems stated above still hold true:</p>

<ul>
<li>The server has to give special treatment to the WebSocket requests, performing a handshake unique to the WebSocket protocol, and implement its new security system.</li>
<li>WebSocket is only supported by the most cutting-edge browser engines on the Desktop, a minority of the web population.</li>
</ul>

<h2>Node.JS koolaid to the rescue</h2>

<p>Node.JS presents developers with a truly unique and exciting possibility: rolling your own scalable non-blocking HTTP server in one of the most popular dynamic scripting languages of all time, with a simplistic API.</p>

<p>Writing a (dummy) long-polling server is as easy as:</p>

<div class="snippet"><a href="websockets-socketio/longpolling.js" class="code-link">longpolling.js</a><pre><code><span class="pln">http</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">request</span><span class="pun">,</span><span class="pln"> response</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; setTimeout</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; response</span><span class="pun">.</span><span class="pln">writeHead</span><span class="pun">(</span><span class="lit">200</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="str">'Content-Type'</span><span class="pun">:</span><span class="pln"> </span><span class="str">'text/plain'</span><span class="pun">});</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; response</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(</span><span class="str">'Hello World\n'</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">},</span><span class="pln"> </span><span class="lit">20000</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}).</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">8124</span><span class="pun">);</span></code></pre></div>

<p>Even with this simple API, consolidating your app logic in a way that works across all transports can be difficult.</p>

<p><code>Socket.IO-node</code> is here to help: Here's a chat server in 10 lines of code that also announces (broadcasts) who connects to the server:</p>

<div class="snippet"><a href="websockets-socketio/broadcasts.js" class="code-link">broadcasts.js</a><pre><code><span class="kwd">var</span><span class="pln"> buffer </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[];</span><span class="pln"><br />io</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'connection'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">client</span><span class="pun">){</span><span class="pln"><br />&nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">send</span><span class="pun">({</span><span class="pln"> buffer</span><span class="pun">:</span><span class="pln"> buffer </span><span class="pun">});</span><span class="pln"><br />&nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">broadcast</span><span class="pun">({</span><span class="pln"> announcement</span><span class="pun">:</span><span class="pln"> client</span><span class="pun">.</span><span class="pln">sessionId </span><span class="pun">+</span><span class="pln"> </span><span class="str">' connected'</span><span class="pln"> </span><span class="pun">});</span><span class="pln"><br /><br />&nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'message'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">message</span><span class="pun">){</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">var</span><span class="pln"> msg </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> message</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="pln">client</span><span class="pun">.</span><span class="pln">sessionId</span><span class="pun">,</span><span class="pln"> message</span><span class="pun">]</span><span class="pln"> </span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; buffer</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">.</span><span class="pln">length </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">15</span><span class="pun">)</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">shift</span><span class="pun">();</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">broadcast</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">});</span><span class="pln"><br /><br />&nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'disconnect'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(){</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">broadcast</span><span class="pun">({</span><span class="pln"> announcement</span><span class="pun">:</span><span class="pln"> client</span><span class="pun">.</span><span class="pln">sessionId </span><span class="pun">+</span><span class="pln"> </span><span class="str">' disconnected'</span><span class="pln"> </span><span class="pun">});</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">});</span></code></pre></div>

<p>And the best part is, under the hood, it'll handle your WebSocket, WebSocket over Flash, long polling, multipart and iframe connections. Sweet, isn't it?</p>

<h2>Further reading</h2>

<p>If you want to learn more about Socket.IO, be sure to watch the <a href="http://github.com/learnboost/socket.io">git</a> <a href="http://github.com/learnboost/socket.io-node">repositories</a>, and check out some of the projects people have created with it:</p>

<ul>
<li><a href="http://github.com/substack/dnode">http://github.com/substack/dnode</a></li>
<li><a href="http://github.com/jacobthornton/space-tweet">http://github.com/jacobthornton/space-tweet</a></li>
<li><a href="http://github.com/mkilling/alfamegle">http://github.com/mkilling/alfamegle</a></li>
<li><a href="http://github.com/deserat/sock-drawer/">http://github.com/deserat/sock-drawer/</a></li>
<li><a href="http://github.com/gerad/lazeroids-node/">http://github.com/gerad/lazeroids-node/</a></li>
</ul><hr style="clear:both" /><div class="body" id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
var disqus_url = "http://howtonode.org/websockets-socketio";
//]]>
</script>
<script src="http://disqus.com/forums/howtonodeorg/embed.js" type="text/javascript"></script><a href="http://disqus.com/forums/howtonodeorg/?url=ref" class="view-thread">View the discussion thread.</a><a href="http://disqus.com/" class="dsq-brlink">blog comments powered by<span class="logo-disqus">Disqus</span></a>
<script type="text/javascript">
//<![CDATA[
(function() {
  var links = document.getElementsByTagName('a');
  var query = '?';
  for(var i = 0; i < links.length; i++) {
    if(links[i].href.indexOf('#disqus_thread') >= 0) {
      query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&amp;';
    }
  }
  document.write('<script charset="utf-8" type="text/javascript" src="//disqus.com/forums/howtonodeorg/get_num_replies.js' + query + '"></' + 'script>');
})();


//]]>
</script>
</div></div><div id="sidebar"><div class="aside author"><h4>About the Author</h4><img src="https://www.gravatar.com/avatar/486e20e16ef676a02ac0299d2f92b813?r=pg&amp;s=200.jpg&amp;d=identicon" class="headshot" /><dl><dt>Name:</dt><dd>Guillermo Rauch</dd></dl><dl><dt>Github:</dt><dd><a href="https://github.com/guille">guille</a></dd></dl><dl><dt>Twitter:</dt><dd><a href="https://twitter.com/rauchg">rauchg</a></dd></dl></div><div class="aside"><h4>About this Article</h4><a href="http://twitter.com/share" data-count="horizontal" data-via="creationix" class="twitter-share-button">Tweet</a><script src="http://platform.twitter.com/widgets.js"></script><dl title="Wed Sep 29 2010 12:11:39 GMT+0530 (IST)"><dt>Date Released:</dt><dd>Wednesday, September 29, 2010</dd></dl><dl><dt>Code Samples:</dt><dd><ul><li><a href="websockets-socketio/socketio-sample.js">socketio-sample.js</a></li><li><a href="websockets-socketio/longpolling.js">longpolling.js</a></li><li><a href="websockets-socketio/broadcasts.js">broadcasts.js</a></li></ul></dd></dl><dl><dt>Revisions:</dt><dd><ul></ul></dd></dl></div><div class="bubble"><h3>About HowToNode.org</h3>

<p>HowToNode.org is a community supported blog created by <a href="http://creationix.com/">Tim Caswell</a>. The purpose of the blog is to teach how to do various tasks in <a href="http://nodejs.org/">node.js</a> as well as teach fundamental concepts that are needed to write effective code.</p>

<p>This site is powered by <a href="http://github.com/creationix/wheat">Wheat</a>, a git based blogging engine written in <a href="http://nodejs.org/">node.JS</a>.</p>

<p>The content for this site is stored in a <a href="http://github.com/creationix/howtonode.org">git repository</a> that anyone can fork, write an article, and send a pull request. If your article passes the quality standards it will be published and help support the greater node community.</p></div></div><div id="footer"><p>&copy; 2011-2014 Tim Caswell under the MIT license.</p><p>Content and articles are copyrighted to the individual authors. Design by&nbsp;<a href="https://bengourley.co.uk/">Ben Gourley</a>. All code snippets used in the examples are in the public domain.</p><p>Wheat v2 running on node.js v16.4.2</p></div></div>
<script type="text/javascript">
//<![CDATA[
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
//]]>
</script>

<script type="text/javascript">
//<![CDATA[
try {
var pageTracker = _gat._getTracker("UA-12824411-1");
pageTracker._trackPageview();
} catch(err) {}
//]]>
</script>
</body>
<!-- Mirrored from localhost:8080/websockets-socketio by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:58:21 GMT -->
</html>