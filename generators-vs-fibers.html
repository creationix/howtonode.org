<!DOCTYPE html>
<html lang="en">
<!-- Mirrored from localhost:8080/generators-vs-fibers by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:56:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8" /><title>Generators vs Fibers - How To Node - NodeJS</title><meta name="description" content="Learn the zen of coding in NodeJS." /><meta name="viewport" content="width=device-width" /><link href="style.css" rel="stylesheet" /><link href="print.css" rel="stylesheet" media="print" /><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="feed.xml" /><link href="favicon.ico" rel="icon" type="image/x-icon" /></head><body><div id="container"><div id="header"><a href="index.html"><img src="logo.png" alt="How to Node" class="logo" /><div class="tagline">The zen of coding in node.js</div></a></div><div id="main"><div class="article"><h1><a href="generators-vs-fibers.html">Generators vs Fibers</a></h1><p>Both ES6 generators and <a href="https://github.com/laverdet/node-fibers">node-fibers</a> can be used to block a coroutine while waiting on some I/O without blocking the entire process.</p>

<p>This means that you can wait for an I/O result within your code but still have the performance benefits of the single-threaded,  non-blocking I/O model you all know and love.</p>

<p>Both can do this for arbitrarily deep call stacks. The main difference between the capabilities of the two is how explicit the syntax is.  It's the classic battle between wanting to be safe while wanting to be flexible.</p>

<hr />

<h2>Generators - Safe, but Annoyingly Explicit</h2>

<p>In code that uses generators there is a technique whereby a library will yield continuables or promises and the generator runner will pass in the callback, suspend the generator body, and resume when the callback gets called.</p>

<p>I will use my library, <a href="https://github.com/creationix/gen-run">gen-run</a>, in these examples because it's very simple and is the one I know best.  There are many others I link to in the gen-run <a href="https://github.com/creationix/gen-run/blob/master/README.md#credits">credits</a>.</p>

<h3>The Server</h3>

<p>We'll start out by writing a simple HTTP server that uses generators to power the request handling logic.  It could look something like this.</p>

<div class="snippet"><a href="generators-vs-fibers/generator-server.js" class="code-link">generator-server.js<span class="hash">#server</span></a><pre><code><span class="pln">http</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> onRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; run</span><span class="pun">(</span><span class="pln">handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> onResponseBody</span><span class="pun">(</span><span class="pln">err</span><span class="pun">,</span><span class="pln"> body</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">statusCode </span><span class="pun">=</span><span class="pln"> </span><span class="lit">500</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Type"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"text/plain"</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(</span><span class="pln">err</span><span class="pun">.</span><span class="pln">stack</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">statusCode </span><span class="pun">=</span><span class="pln"> </span><span class="lit">200</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Type"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"application/json"</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Length"</span><span class="pun">,</span><span class="pln"> body</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(</span><span class="pln">body</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}).</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">3000</span><span class="pun">);</span><span class="pln"><br />console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server running at http:</span></code></pre></div>

<h3>The Handler</h3>

<p>Initially when we write our programs, we often use canned data or otherwise have less I/O to perform to accomplish the given task.  In this example, we're using a simple module that returns the result directly.</p>

<div class="snippet"><a href="generators-vs-fibers/query.js" class="code-link">query.js</a><pre><code><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; method</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">method</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; url</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">url</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; date</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">).</span><span class="pln">toString</span><span class="pun">()</span><span class="pln"><br />&nbsp; </span><span class="pun">};</span><span class="pln"><br /></span><span class="pun">};</span></code></pre></div>

<p>Now our main app logic can be written.  Remember that the server expects us to be in a generator so let's write the logic as a generator.</p>

<p>We want each result to be tagged with the request count as it came into the server.  A simple shared variable that gets incremented at the beginning of each request should do the trick.</p>

<div class="snippet"><a href="generators-vs-fibers/generator-server.js" class="code-link">generator-server.js<span class="hash">#handler</span></a><pre><code><span class="kwd">var</span><span class="pln"> requestCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; requestCount</span><span class="pun">++;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">req</span><span class="pun">);</span><span class="pln"><br />&nbsp; result</span><span class="pun">.</span><span class="pln">requestCount </span><span class="pun">=</span><span class="pln"> requestCount</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Buffer</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>You can call this with as many concurrent requests as you want.  Each will have the correct <code>requestCount</code> because of run-to-finish semantics of JavaScript.  Even inside the bodies of generators, arbitrary function calls can't suspend your code.</p>

<h3>Modified Handler</h3>

<p>Now suppose that down the line, our query function needed to actually do things and perform some I/O.</p>

<p>First we'll change the <code>query</code> function to return a continuable and/or accept a callback.  This is a common pattern for many node libraries that need to perform I/O.</p>

<div class="snippet"><a href="generators-vs-fibers/continuable-query.js" class="code-link">continuable-query.js</a><pre><code><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> query</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="com">// If the callback isn't passed in, return a continuable.</span><span class="pln"><br />&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">callback</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> query</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> req</span><span class="pun">);</span><span class="pln"><br /><br />&nbsp; </span><span class="com">// Simulate I/O with a timer</span><span class="pln"><br />&nbsp; setTimeout</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; callback</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; method</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">method</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; url</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">url</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; date</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">).</span><span class="pln">toString</span><span class="pun">()</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">});</span><span class="pln"><br />&nbsp; </span><span class="pun">},</span><span class="pln"> </span><span class="lit">100</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>We thought ahead and put the body of our handler in a generator to ease the transition, but that function call needs to change.  The query function now returns a continuable or expects a callback last.  Our handler function can now look like this.</p>

<div class="snippet"><a href="generators-vs-fibers/generator-server.js" class="code-link">generator-server.js<span class="hash">#continuable-handler</span></a><pre><code><span class="kwd">var</span><span class="pln"> requestCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; requestCount</span><span class="pun">++;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">yield</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">req</span><span class="pun">);</span><span class="pln"><br />&nbsp; result</span><span class="pun">.</span><span class="pln">requestCount </span><span class="pun">=</span><span class="pln"> requestCount</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Uh-Oh!</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Buffer</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>Now we have that big bright <code>yield</code> keyword in there.  We can see plainly that our <code>requestCount</code> variable is in danger of a race condition.  What happens if a second request comes in while we're still waiting on the query from the first request?  They will clobber each other and both requests will be marked as #3, that's what!</p>

<p>Good thing we were forced to change our calling syntax to help us see the danger.</p>

<h3>Modified Again</h3>

<p>Another transform we could have done is re-write <code>query</code> as a generator itself allowing for deep coroutines with <code>function*</code> at every definition and <code>yield*</code> at every call.</p>

<div class="snippet"><a href="generators-vs-fibers/generator-query.js" class="code-link">generator-query.js</a><pre><code><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="com">// Simulate I/O with a sleep</span><span class="pln"><br />&nbsp; </span><span class="kwd">yield</span><span class="pun">*</span><span class="pln"> sleep</span><span class="pun">(</span><span class="lit">100</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="com">// And then return the result!</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; method</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">method</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; url</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">url</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; date</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">).</span><span class="pln">toString</span><span class="pun">()</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">};</span><span class="pln"><br /><br /></span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> sleep</span><span class="pun">(</span><span class="pln">ms</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">yield</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; setTimeout</span><span class="pun">(</span><span class="pln">callback</span><span class="pun">,</span><span class="pln"> ms</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="pun">};</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>In this case we insert a delegating <code>yield*</code> instead of a plain <code>yield</code> and it works the same as the previous change.</p>

<div class="snippet"><a href="generators-vs-fibers/generator-server.js" class="code-link">generator-server.js<span class="hash">#generator-handler</span></a><pre><code><span class="kwd">var</span><span class="pln"> requestCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; requestCount</span><span class="pun">++;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">yield</span><span class="pun">*</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">req</span><span class="pun">);</span><span class="pln"><br />&nbsp; result</span><span class="pun">.</span><span class="pln">requestCount </span><span class="pun">=</span><span class="pln"> requestCount</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Uh-Oh!</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Buffer</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>In summary, generators allow for all kinds of nice tricks where you can block on I/O without actually blocking the process, however these require invasive changes to your code (much the same as callbacks act today).</p>

<h2>Fibers - Powerful, but Flexible</h2>

<p>Long before generators landed in V8 and node.js, Marcel released a library known as <a href="https://github.com/laverdet/node-fibers">node-fibers</a>.  This clever little library allows you to use full coroutines in any version of node that the addon compiles against.</p>

<p>I'll repeat the same examples here, but using fibers instead of generators for easy comparison.</p>

<h3>The Server</h3>

<p>Our server is slightly different because the fiber API is quite different than the gen-run and generator APIs.</p>

<div class="snippet"><a href="generators-vs-fibers/fiber-server.js" class="code-link">fiber-server.js<span class="hash">#server</span></a><pre><code><span class="pln">http</span><span class="pun">.</span><span class="pln">createServer</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> onRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="typ">Fiber</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">var</span><span class="pln"> body</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; body </span><span class="pun">=</span><span class="pln"> handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">err</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">statusCode </span><span class="pun">=</span><span class="pln"> </span><span class="lit">500</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Type"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"text/plain"</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; res</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(</span><span class="pln">err</span><span class="pun">.</span><span class="pln">stack</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">statusCode </span><span class="pun">=</span><span class="pln"> </span><span class="lit">200</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Type"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"application/json"</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="pln">setHeader</span><span class="pun">(</span><span class="str">"Content-Length"</span><span class="pun">,</span><span class="pln"> body</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"><br />&nbsp; &nbsp; res</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(</span><span class="pln">body</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="pun">}).</span><span class="pln">run</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">}).</span><span class="pln">listen</span><span class="pun">(</span><span class="lit">3000</span><span class="pun">);</span><span class="pln"><br />console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">"Server running at http:</span></code></pre></div>

<p>We create a fiber for our code to run in.  With fibers there is no distinction between generators, iterators, or normal functions.  They are all just vanilla functions.  Also this means there is no <code>yield</code> or <code>yield*</code>.  Only normal function calls.</p>

<p>Also within the body of the fiber, <code>try..catch</code> works just like it does with sync code because the code <em>is</em> blocking within this fiber.</p>

<h3>The Handler</h3>

<p>We'll start out again with a simple handler.  We'll use the same exact <code>query</code> function from before and the same <code>handleRequest</code> except this one is a plain function.</p>

<div class="snippet"><a href="generators-vs-fibers/fiber-server.js" class="code-link">fiber-server.js<span class="hash">#handler</span></a><pre><code><span class="kwd">var</span><span class="pln"> requestCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> handleRequest</span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; requestCount</span><span class="pun">++;</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">req</span><span class="pun">);</span><span class="pln"><br />&nbsp; result</span><span class="pun">.</span><span class="pln">requestCount </span><span class="pun">=</span><span class="pln"> requestCount</span><span class="pun">;</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Buffer</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>The world is great, everything works and there is no race condition because nobody actually ever suspends the fiber.</p>

<h3>The Change</h3>

<p>Now again, imagine that some time down the line, the authors of the query function need to perform some I/O to accomplish its task.  Well in this case they know they are running inside a fiber. (And even if they didn't know this, they could detect it).</p>

<p>So the only code change required to make query block on I/O is local to the query function.</p>

<div class="snippet"><a href="generators-vs-fibers/fiber-query.js" class="code-link">fiber-query.js</a><pre><code><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">req</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="com">// Simulate I/O with a sleep</span><span class="pln"><br />&nbsp; sleep</span><span class="pun">(</span><span class="lit">100</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="com">// And then return the result!</span><span class="pln"><br />&nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; method</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">method</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; url</span><span class="pun">:</span><span class="pln"> req</span><span class="pun">.</span><span class="pln">url</span><span class="pun">,</span><span class="pln"><br />&nbsp; &nbsp; date</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">).</span><span class="pln">toString</span><span class="pun">()</span><span class="pln"><br />&nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">};</span><span class="pln"><br /><br /></span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Fiber</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'fibers'</span><span class="pun">);</span><span class="pln"><br /></span><span class="kwd">function</span><span class="pln"> sleep</span><span class="pun">(</span><span class="pln">ms</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; </span><span class="kwd">var</span><span class="pln"> fiber </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Fiber</span><span class="pun">.</span><span class="pln">current</span><span class="pun">;</span><span class="pln"><br />&nbsp; setTimeout</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; fiber</span><span class="pun">.</span><span class="pln">run</span><span class="pun">();</span><span class="pln"><br />&nbsp; </span><span class="pun">},</span><span class="pln"> ms</span><span class="pun">);</span><span class="pln"><br />&nbsp; </span><span class="typ">Fiber</span><span class="pun">.</span><span class="kwd">yield</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">}</span></code></pre></div>

<p>That's it.  The rest of the code will continue to work as before.  You test it locally and everything works great.  You didn't have to change the signature of any other function that consumed this library.</p>

<p>Then you push this code to production where the server hits a higher concurrency load and people start complaining that their <code>requestCount</code>s aren't always accurate.  The problem you discover after many hours of painful debugging is that the <code>query</code> function back in <code>handleRequest</code> that didn't need to be changed syntacticly did change behavior.  It suspended the fiber and let other concurrent requests clobber the shared <code>requestCount</code> variable.</p>

<h2>Lesson Learned</h2>

<p>Next time you complain that adding an async feature to a library causes all consumers of this API to be changed as well, remember that along with that pain is protection.  You can't have the protection without the pain.</p>

<p>Both styles of coroutines are powerful with unique strengths and weaknesses.</p>

<p>Safety or flexibility, choose one.</p><hr style="clear:both" /><div class="body" id="disqus_thread"></div>
<script type="text/javascript">
//<![CDATA[
var disqus_url = "http://howtonode.org/generators-vs-fibers";
//]]>
</script>
<script src="http://disqus.com/forums/howtonodeorg/embed.js" type="text/javascript"></script><a href="http://disqus.com/forums/howtonodeorg/?url=ref" class="view-thread">View the discussion thread.</a><a href="http://disqus.com/" class="dsq-brlink">blog comments powered by<span class="logo-disqus">Disqus</span></a>
<script type="text/javascript">
//<![CDATA[
(function() {
  var links = document.getElementsByTagName('a');
  var query = '?';
  for(var i = 0; i < links.length; i++) {
    if(links[i].href.indexOf('#disqus_thread') >= 0) {
      query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&amp;';
    }
  }
  document.write('<script charset="utf-8" type="text/javascript" src="//disqus.com/forums/howtonodeorg/get_num_replies.js' + query + '"></' + 'script>');
})();


//]]>
</script>
</div></div><div id="sidebar"><div class="aside author"><h4>About the Author</h4><img src="https://www.gravatar.com/avatar/c953ddd239707998340e1a6fbb3eeb46?r=pg&amp;s=200.jpg&amp;d=identicon" class="headshot" /><dl><dt>Name:</dt><dd>Tim Caswell</dd></dl><dl><dt>Github:</dt><dd><a href="https://github.com/creationix">creationix</a></dd></dl><dl><dt>Twitter:</dt><dd><a href="https://twitter.com/creationix">creationix</a></dd></dl><dl><dt>Location:</dt><dd>Red Lick, TX</dd></dl><dl><dt>Links:</dt><dd><a href="http://creationix.com/">Homepage</a></dd></dl></div><div class="aside"><h4>About this Article</h4><a href="http://twitter.com/share" data-count="horizontal" data-via="creationix" class="twitter-share-button">Tweet</a><script src="http://platform.twitter.com/widgets.js"></script><dl title="Mon Sep 02 2013 17:08:56 GMT-0500 (CDT)"><dt>Date Released:</dt><dd>Monday, September  2, 2013</dd></dl><dl><dt>Node Version:</dt><dd><a href="http://github.com/joyent/node/tree/v0.11.6">node v0.11.6</a></dd></dl><dl><dt>Code Samples:</dt><dd><ul><li><a href="generators-vs-fibers/generator-server.js">generator-server.js</a></li><li><a href="generators-vs-fibers/query.js">query.js</a></li><li><a href="generators-vs-fibers/continuable-query.js">continuable-query.js</a></li><li><a href="generators-vs-fibers/generator-query.js">generator-query.js</a></li><li><a href="generators-vs-fibers/fiber-server.js">fiber-server.js</a></li><li><a href="generators-vs-fibers/fiber-query.js">fiber-query.js</a></li></ul></dd></dl><dl><dt>Revisions:</dt><dd><ul></ul></dd></dl></div><div class="bubble"><h3>About HowToNode.org</h3>

<p>HowToNode.org is a community supported blog created by <a href="http://creationix.com/">Tim Caswell</a>. The purpose of the blog is to teach how to do various tasks in <a href="http://nodejs.org/">node.js</a> as well as teach fundamental concepts that are needed to write effective code.</p>

<p>This site is powered by <a href="http://github.com/creationix/wheat">Wheat</a>, a git based blogging engine written in <a href="http://nodejs.org/">node.JS</a>.</p>

<p>The content for this site is stored in a <a href="http://github.com/creationix/howtonode.org">git repository</a> that anyone can fork, write an article, and send a pull request. If your article passes the quality standards it will be published and help support the greater node community.</p></div></div><div id="footer"><p>&copy; 2011-2014 Tim Caswell under the MIT license.</p><p>Content and articles are copyrighted to the individual authors. Design by&nbsp;<a href="https://bengourley.co.uk/">Ben Gourley</a>. All code snippets used in the examples are in the public domain.</p><p>Wheat v2 running on node.js v16.4.2</p></div></div>
<script type="text/javascript">
//<![CDATA[
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
//]]>
</script>

<script type="text/javascript">
//<![CDATA[
try {
var pageTracker = _gat._getTracker("UA-12824411-1");
pageTracker._trackPageview();
} catch(err) {}
//]]>
</script>
</body>
<!-- Mirrored from localhost:8080/generators-vs-fibers by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 13 Jul 2021 13:56:55 GMT -->
</html>